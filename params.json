{"body":"Leaf is an extremely simple Java web framework which takes concepts from Google Sitebricks and Apache Wicket, rolls them together, chucks out the complicated bloat, mixes in a few new ideas and makes sure the whole lot runs really well on Google App Engine or any servlet container.\r\n\r\nIt is built on top of Google's Guice Servlet framework so you get all of that dependency injection goodness and easy configuration for free.  HTML websites and headless web services are extremely easy to implement and configure using LeafLeaf module that extends ServletModule.\r\n\r\nLeaf is simple - a lot more simple than most web frameworks because it does not try to replicate features that are already handled by Guice Servlet or can be best handled with Google Web Toolkit on the client.\r\n\r\n## The Basics - Templates, Exchangers and configuration.\r\n\r\n\r\n### Html Template\r\n\r\nLike Apache Wicket, Leaf uses its own super simple markup template system that matches an id in your well formed markup to a Java component that can modify that markup.  There is no scripting language.  Scripting in markup files is bad.  The attached Java component controls all modifications to the markup so you can debug every step in your IDE.\r\n\r\n```\r\nHelloWorld.html\r\n<html>\r\n  <body>\r\n    <span l:x=\"hello\">This will be replaced by the Exchanger field \"hello\"</span>\r\n    <span l:x=\"world\">This will be replaced by the Exchanger field \"world\"</span>!\r\n  </body>\r\n</html>\r\n```\r\n\r\n### Java Component and configuration Module\r\n\r\nThe attributes l:x are used to find a Java [Exchanger](https://github.com/vercer/leaf/blob/master/src/main/java/com/vercer/leaf/exchange/Exchanger.java) that can replace the markup with anything you like.  An Exchanger is very simple to implement and gives you complete controls of the markup that ends up being written in the response.\r\n\r\n```\r\npublic interface Exchanger\r\n{\r\n  Markup exchange(Markup markup);\r\n}\r\n```\r\n\r\nMarkup is an immutable object that represents a special xml tag letting you easily compose a tree of tags to create an html document.  Unlike an XML document, not all tags in your template file become a Markup object but only the ones that you need to control.  The default Parser creates a Markup object for all elements containing an l:x attribute.\r\n\r\nThe matching Exchanger is found by looking at the Page's properties for a getter with the same name as the l:x attribute.  Here was use the excellent Project Lombok to make our Java code more succinct - notice the @Getter annotations to create properties from fields. \r\n\r\n```\r\nTable.java\r\n\r\n  public class HelloWorld extends Template\r\n  {\r\n      @Getter\r\n      Label hello = new Label(\"Hello\");\r\n\r\n      @Getter\r\n      String world = \"World\";\r\n  }\r\n```\r\n\r\nHere we have a top level class called Table which will look for an html file in the same directory.  Templates and components live side by side - you can think of them as different aspects to the same logical unit.  \r\n\r\nWhen the Table Template parses its markup file it will see the l:x=\"hello\" attribute and look for a property with the same name, finding the Label value which extends Exchanger and knows how to modify the markup to show \"Hello\".\r\n\r\nNext it finds the property \"world\" and returns its String value... but wait we need an Exchanger to modify our markup not a String!  This is where things get interesting.  Leaf needs to convert the String into an Exchanger.\r\n\r\nMany places in Leaf use a TypeConverter to transform an object to another type.  You are in complete control of how this is configured so ultimately you have complete control of how properties are turned into Markup.  By default, Leaf registers a CharSequenceToLabel converter which will turn a String into a Label object.  There are many useful converters registered by default that you can override as you like.\r\n\r\n### Configuration\r\n\r\nLeaf inherits its Guice based configuration module from Guice Servlet allowing you to inject all of the standard servlet classes into your top level reply objects.\r\n\r\n```\r\npublic class GuideLeafModule extends LeafModule\r\n{\r\n  @Override\r\n  protected void configure(Settings.SettingsBuilder settings)\r\n  {\r\n    reply(HelloWorld.class).match(\"/hello-world\");\r\n  }","google":"","name":"Leaf","tagline":"Super simple web application framework built on Guice","note":"Don't delete this file! It's used internally to help with page regeneration."}